# Generated by savvy: do not edit by hand
#
# Note:
#   This wrapper file is named as `000-wrappers.R` so that this file is loaded
#   first, which allows users to override the functions defined here (e.g., a
#   print() method for an enum).

#' @useDynLib skiagd, .registration = TRUE
#' @keywords internal
NULL

# Check class and extract the external pointer embedded in the environment
.savvy_extract_ptr <- function(e, class) {
  if(is.null(e)) {
    return(NULL)
  }

  if(inherits(e, class)) {
    e$.ptr
  } else {
    msg <- paste0("Expected ", class, ", got ", class(e)[1])
    stop(msg, call. = FALSE)
  }
}

# Prohibit modifying environments

#' @export
`$<-.savvy_skiagd__sealed` <- function(x, name, value) {
  class <- gsub("__bundle$", "", class(x)[1])
  stop(class, " cannot be modified", call. = FALSE)
}

#' @export
`[[<-.savvy_skiagd__sealed` <- function(x, i, value) {
  class <- gsub("__bundle$", "", class(x)[1])
  stop(class, " cannot be modified", call. = FALSE)
}

#' Fills canvas with color
#'
#' @param size Canvas size.
#' @param fill Integers of length 4 (RGBA).
#' @returns A raw vector of picture.
#' @noRd
`sk_absolute_fill` <- function(`size`, `fill`) {
  .Call(savvy_sk_absolute_fill__impl, `size`, `fill`)
}

#' Takes a raw vector of picture and returns PNG data
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @returns A raw vector of PNG data.
#' @noRd
`sk_as_png` <- function(`size`, `curr_bytes`, `mat`) {
  .Call(savvy_sk_as_png__impl, `size`, `curr_bytes`, `mat`)
}

#' Draws atlas
#'
#' This function doesn't take `sprites` (offsets for the sprites) argument.
#' The entire image is always used as a sprite.
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param png_bytes PNG bytes.
#' @param scale Scale factor.
#' @param radians Rotation factor.
#' @param tx X translation.
#' @param ty Y translation.
#' @param anchor_x X coordinates of anchor points.
#' @param anchor_y Y coordinates of anchor points.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_atlas` <- function(`size`, `curr_bytes`, `mat`, `props`, `png_bytes`, `scale`, `radians`, `tx`, `ty`, `anchor_x`, `anchor_y`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_atlas__impl, `size`, `curr_bytes`, `mat`, `props`, `png_bytes`, `scale`, `radians`, `tx`, `ty`, `anchor_x`, `anchor_y`)
}

#' Draws circles
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param x X coordinates of center.
#' @param y Y coordinates of center.
#' @param radius Circle radius.
#' @param width Stroke width.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_circle` <- function(`size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `radius`, `width`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_circle__impl, `size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `radius`, `width`, `color`)
}

#' Draws outer and inner rounded rectangles
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param outer_left X coordinates of the left edge of the outer rectangle.
#' @param outer_top Y coordinates of the top edge of the outer rectangle.
#' @param outer_right X coordinates of the right edge of the outer rectangle.
#' @param outer_bottom Y coordinates of the bottom edge of the outer rectangle.
#' @param outer_rx Axis lengths on X-axis of outer oval describing rounded corners.
#' @param outer_ry Axis lengths on Y-axis of outer oval describing rounded corners.
#' @param inner_left X coordinates of the left edge of the inner rectangle.
#' @param inner_top Y coordinates of the top edge of the inner rectangle.
#' @param inner_right X coordinates of the right edge of the inner rectangle.
#' @param inner_bottom Y coordinates of the bottom edge of the inner rectangle.
#' @param inner_rx Axis lengths on X-axis of inner oval describing rounded corners.
#' @param inner_ry Axis lengths on Y-axis of inner oval describing rounded corners.
#' @param width Stroke width.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_diff_rect` <- function(`size`, `curr_bytes`, `mat`, `props`, `outer_left`, `outer_top`, `outer_right`, `outer_bottom`, `outer_rx`, `outer_ry`, `inner_left`, `inner_top`, `inner_right`, `inner_bottom`, `inner_rx`, `inner_ry`, `width`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_diff_rect__impl, `size`, `curr_bytes`, `mat`, `props`, `outer_left`, `outer_top`, `outer_right`, `outer_bottom`, `outer_rx`, `outer_ry`, `inner_left`, `inner_top`, `inner_right`, `inner_bottom`, `inner_rx`, `inner_ry`, `width`, `color`)
}

#' Draws lines
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param from_x X coordinates of start points.
#' @param from_y Y coordinates of start points.
#' @param to_x X coordinates of end points.
#' @param to_y Y coordinates of end points.
#' @param width Stroke width.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_line` <- function(`size`, `curr_bytes`, `mat`, `props`, `from_x`, `from_y`, `to_x`, `to_y`, `width`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_line__impl, `size`, `curr_bytes`, `mat`, `props`, `from_x`, `from_y`, `to_x`, `to_y`, `width`, `color`)
}

#' Draws SVG paths
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat1 Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param svg SVG strings to draw.
#' @param width Stroke width.
#' @param color Colors.
#' @param mat2 Matrix for transforming SVG path.
#' @param fill_type FillType.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_path` <- function(`size`, `curr_bytes`, `mat1`, `props`, `svg`, `width`, `color`, `mat2`, `fill_type`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  `fill_type` <- .savvy_extract_ptr(`fill_type`, "FillType")
  .Call(savvy_sk_draw_path__impl, `size`, `curr_bytes`, `mat1`, `props`, `svg`, `width`, `color`, `mat2`, `fill_type`)
}

#' Draws PNG data as an image on canvas
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param png_bytes PNG data to draw.
#' @param left_top Offset for drawing PNG image.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_png` <- function(`size`, `curr_bytes`, `mat`, `props`, `png_bytes`, `left_top`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_png__impl, `size`, `curr_bytes`, `mat`, `props`, `png_bytes`, `left_top`)
}

#' Draws points with specified mode
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param x X coordinates of points.
#' @param y Y coordinates of points.
#' @param mode PointMode.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_points` <- function(`size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `mode`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  `mode` <- .savvy_extract_ptr(`mode`, "PointMode")
  .Call(savvy_sk_draw_points__impl, `size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `mode`)
}

#' Draws rounded rectangles
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param left X coordinates of the left edge of the rectangles.
#' @param top Y coordinates of the top edge of the rectangles.
#' @param right X coordinates of the right edge of the rectangles.
#' @param bottom Y coordinates of the bottom edge of the rectangles.
#' @param rx Axis lengths on X-axis of oval describing rounded corners.
#' @param ry Axis lengths on Y-axis of oval describing rounded corners.
#' @param width Stroke width.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_rounded_rect` <- function(`size`, `curr_bytes`, `mat`, `props`, `left`, `top`, `right`, `bottom`, `rx`, `ry`, `width`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_rounded_rect__impl, `size`, `curr_bytes`, `mat`, `props`, `left`, `top`, `right`, `bottom`, `rx`, `ry`, `width`, `color`)
}

#' Draws text as textblobs
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param text Text strings.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_text` <- function(`size`, `curr_bytes`, `mat`, `props`, `text`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_text__impl, `size`, `curr_bytes`, `mat`, `props`, `text`, `color`)
}

#' Draws textblobs
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param text Text strings.
#' @param x X coordinates of points where to draw each character.
#' @param y Y coordinates of points where to draw each character.
#' @param color Colors.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_textblob` <- function(`size`, `curr_bytes`, `mat`, `props`, `text`, `x`, `y`, `color`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_textblob__impl, `size`, `curr_bytes`, `mat`, `props`, `text`, `x`, `y`, `color`)
}

#' Draws textpaths
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat1 Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param text Text strings to draw along SVG paths.
#' @param svg SVG paths.
#' @param mat2 Matrix for transforming SVG paths.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_textpath` <- function(`size`, `curr_bytes`, `mat1`, `props`, `text`, `svg`, `mat2`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_draw_textpath__impl, `size`, `curr_bytes`, `mat1`, `props`, `text`, `svg`, `mat2`)
}

#' Draws vertices
#'
#' @param size Canvas size.
#' @param curr_bytes Current canvas state.
#' @param mat Matrix for transforming picture.
#' @param props PaintAttrs.
#' @param x X coordinates of points.
#' @param y Y coordinates of points.
#' @param color Colors of vertices.
#' @param mode VertexMode.
#' @returns A raw vector of picture.
#' @noRd
`sk_draw_vertices` <- function(`size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `color`, `mode`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  `mode` <- .savvy_extract_ptr(`mode`, "VertexMode")
  .Call(savvy_sk_draw_vertices__impl, `size`, `curr_bytes`, `mat`, `props`, `x`, `y`, `color`, `mode`)
}

#' Get text width
#'
#' @param text Text strings.
#' @param props PaintAttrs.
#' @returns A numeric vector.
#' @noRd
`sk_get_text_width` <- function(`text`, `props`) {
  `props` <- .savvy_extract_ptr(`props`, "PaintAttrs")
  .Call(savvy_sk_get_text_width__impl, `text`, `props`)
}


`sk_list_families` <- function() {
  .Call(savvy_sk_list_families__impl)
}

#' Creates a matrix for mapping points
#'
#' @param src_x X coordinates of source points.
#' @param src_y Y coordinates of source points.
#' @param dst_x X coordinates of destination points.
#' @param dst_y Y coordinates of destination points.
#' @returns A numeric vector of length 9.
#' @noRd
`sk_matrix_map_point` <- function(`src_x`, `src_y`, `dst_x`, `dst_y`) {
  .Call(savvy_sk_matrix_map_point__impl, `src_x`, `src_y`, `dst_x`, `dst_y`)
}

#' Returns bounds of SVG paths
#'
#' @param svg SVG notations.
#' @returns A list of numeric vectors.
#' @noRd
`sk_path_bounds` <- function(`svg`) {
  .Call(savvy_sk_path_bounds__impl, `svg`)
}

#' Interpolates between two SVG paths
#'
#' @param value A numeric vector of weights.
#' @param first SVG notation. The second or later elements will be ignored.
#' @param second SVG notation. The second or later elements will be ignored.
#' @returns A character vector.
#' @noRd
`sk_path_interpolate` <- function(`value`, `first`, `second`) {
  .Call(savvy_sk_path_interpolate__impl, `value`, `first`, `second`)
}

#' Transforms SVG paths
#'
#' @param svg SVG notations to transform.
#' @param mat Matrix for transforming SVG paths.
#' @returns A character vector.
#' @noRd
`sk_path_transform` <- function(`svg`, `mat`) {
  .Call(savvy_sk_path_transform__impl, `svg`, `mat`)
}

### wrapper functions for BlendMode


`.savvy_wrap_BlendMode` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("BlendMode", "savvy_skiagd__sealed")
  e
}


#' BlendMode (0-28)
#'
#' `BlendMode` determines how source and destination colors are combined.
#'
#' @details
#' The following blend modes are available in Skia:
#'
#' 1. `Clear`
#' 2. `Src`
#' 3. `Dst`
#' 4. `SrcOver`
#' 5. `DstOver`
#' 6. `SrcIn`
#' 7. `DstIn`
#' 8. `SrcOut`
#' 9. `DstOut`
#' 10. `SrcATop`
#' 11. `DstATop`
#' 12. `Xor`
#' 13. `Plus`
#' 14. `Modulate`
#' 15. `Screen`
#' 16. `Overlay`
#' 17. `Darken`
#' 18. `Lighten`
#' 19. `ColorDodge`
#' 20. `ColorBurn`
#' 21. `HardLight`
#' 22. `SoftLight`
#' 23. `Difference`
#' 24. `Exclusion`
#' 25. `Multiply`
#' 26. `Hue`
#' 27. `Saturation`
#' 28. `Color`
#' 29. `Luminosity`
#'
#' @seealso
#' [BlendMode in skia_safe - Rust](https://rust-skia.github.io/doc/skia_safe/enum.BlendMode.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-blendmode
#' @export
`BlendMode` <- new.env(parent = emptyenv())
`BlendMode`$`Clear` <- .savvy_wrap_BlendMode(0L)
`BlendMode`$`Src` <- .savvy_wrap_BlendMode(1L)
`BlendMode`$`Dst` <- .savvy_wrap_BlendMode(2L)
`BlendMode`$`SrcOver` <- .savvy_wrap_BlendMode(3L)
`BlendMode`$`DstOver` <- .savvy_wrap_BlendMode(4L)
`BlendMode`$`SrcIn` <- .savvy_wrap_BlendMode(5L)
`BlendMode`$`DstIn` <- .savvy_wrap_BlendMode(6L)
`BlendMode`$`SrcOut` <- .savvy_wrap_BlendMode(7L)
`BlendMode`$`DstOut` <- .savvy_wrap_BlendMode(8L)
`BlendMode`$`SrcATop` <- .savvy_wrap_BlendMode(9L)
`BlendMode`$`DstATop` <- .savvy_wrap_BlendMode(10L)
`BlendMode`$`Xor` <- .savvy_wrap_BlendMode(11L)
`BlendMode`$`Plus` <- .savvy_wrap_BlendMode(12L)
`BlendMode`$`Modulate` <- .savvy_wrap_BlendMode(13L)
`BlendMode`$`Screen` <- .savvy_wrap_BlendMode(14L)
`BlendMode`$`Overlay` <- .savvy_wrap_BlendMode(15L)
`BlendMode`$`Darken` <- .savvy_wrap_BlendMode(16L)
`BlendMode`$`Lighten` <- .savvy_wrap_BlendMode(17L)
`BlendMode`$`ColorDodge` <- .savvy_wrap_BlendMode(18L)
`BlendMode`$`ColorBurn` <- .savvy_wrap_BlendMode(19L)
`BlendMode`$`HardLight` <- .savvy_wrap_BlendMode(20L)
`BlendMode`$`SoftLight` <- .savvy_wrap_BlendMode(21L)
`BlendMode`$`Difference` <- .savvy_wrap_BlendMode(22L)
`BlendMode`$`Exclusion` <- .savvy_wrap_BlendMode(23L)
`BlendMode`$`Multiply` <- .savvy_wrap_BlendMode(24L)
`BlendMode`$`Hue` <- .savvy_wrap_BlendMode(25L)
`BlendMode`$`Saturation` <- .savvy_wrap_BlendMode(26L)
`BlendMode`$`Color` <- .savvy_wrap_BlendMode(27L)
`BlendMode`$`Luminosity` <- .savvy_wrap_BlendMode(28L)

#' @export
`$.BlendMode__bundle` <- function(x, name) {
  if (!name %in% c("Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Plus", "Modulate", "Screen", "Overlay", "Darken", "Lighten", "ColorDodge", "ColorBurn", "HardLight", "SoftLight", "Difference", "Exclusion", "Multiply", "Hue", "Saturation", "Color", "Luminosity")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.BlendMode__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("BlendMode cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Plus", "Modulate", "Screen", "Overlay", "Darken", "Lighten", "ColorDodge", "ColorBurn", "HardLight", "SoftLight", "Difference", "Exclusion", "Multiply", "Hue", "Saturation", "Color", "Luminosity")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.BlendMode` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Plus", "Modulate", "Screen", "Overlay", "Darken", "Lighten", "ColorDodge", "ColorBurn", "HardLight", "SoftLight", "Difference", "Exclusion", "Multiply", "Hue", "Saturation", "Color", "Luminosity")[idx]
  if (is.na(label)) {
    stop("Unexpected value for BlendMode", call. = TRUE)
  }
  cat("BlendMode::", label, "\n", sep = "")
}


### associated functions for BlendMode



class(`BlendMode`) <- c("BlendMode__bundle", "savvy_skiagd__sealed")

#' @export
`print.BlendMode__bundle` <- function(x, ...) {
  cat('BlendMode\n')
}

### wrapper functions for Cap


`.savvy_wrap_Cap` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("Cap", "savvy_skiagd__sealed")
  e
}


#' Cap (0-2)
#'
#' `Cap` determines the stroke cap (the geometry drawn at the beginning and end of strokes).
#'
#' @details
#' The following caps are available:
#'
#' * `Butt`: Butt cap.
#' * `Round`: Round cap.
#' * `Square`: Square cap.
#'
#' @seealso
#' [Cap in skia_safe::paint - Rust](https://rust-skia.github.io/doc/skia_safe/paint/enum.Cap.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-cap
#' @export
`Cap` <- new.env(parent = emptyenv())
`Cap`$`Butt` <- .savvy_wrap_Cap(0L)
`Cap`$`Round` <- .savvy_wrap_Cap(1L)
`Cap`$`Square` <- .savvy_wrap_Cap(2L)

#' @export
`$.Cap__bundle` <- function(x, name) {
  if (!name %in% c("Butt", "Round", "Square")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.Cap__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("Cap cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Butt", "Round", "Square")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.Cap` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Butt", "Round", "Square")[idx]
  if (is.na(label)) {
    stop("Unexpected value for Cap", call. = TRUE)
  }
  cat("Cap::", label, "\n", sep = "")
}


### associated functions for Cap



class(`Cap`) <- c("Cap__bundle", "savvy_skiagd__sealed")

#' @export
`print.Cap__bundle` <- function(x, ...) {
  cat('Cap\n')
}

### wrapper functions for FillType


`.savvy_wrap_FillType` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("FillType", "savvy_skiagd__sealed")
  e
}


#' FillType (0-3)
#'
#' `FillType` determines how paths are drawn.
#' This is for [add_path()] only. Not used in other functions.
#'
#' @details
#' The following `FillType` are available:
#'
#' * `Winding`
#' * `EvenOdd`
#' * `InverseWinding`
#' * `InverseEvenOdd`
#'
#' @seealso
#' [FillType in skia_safe::path - Rust](https://rust-skia.github.io/doc/skia_safe/path/enum.FillType.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-filltype
#' @export
`FillType` <- new.env(parent = emptyenv())
`FillType`$`Winding` <- .savvy_wrap_FillType(0L)
`FillType`$`EvenOdd` <- .savvy_wrap_FillType(1L)
`FillType`$`InverseWinding` <- .savvy_wrap_FillType(2L)
`FillType`$`InverseEvenOdd` <- .savvy_wrap_FillType(3L)

#' @export
`$.FillType__bundle` <- function(x, name) {
  if (!name %in% c("Winding", "EvenOdd", "InverseWinding", "InverseEvenOdd")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.FillType__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("FillType cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Winding", "EvenOdd", "InverseWinding", "InverseEvenOdd")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.FillType` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Winding", "EvenOdd", "InverseWinding", "InverseEvenOdd")[idx]
  if (is.na(label)) {
    stop("Unexpected value for FillType", call. = TRUE)
  }
  cat("FillType::", label, "\n", sep = "")
}


### associated functions for FillType



class(`FillType`) <- c("FillType__bundle", "savvy_skiagd__sealed")

#' @export
`print.FillType__bundle` <- function(x, ...) {
  cat('FillType\n')
}

### wrapper functions for FontStyle


`.savvy_wrap_FontStyle` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("FontStyle", "savvy_skiagd__sealed")
  e
}


#' FontStyle (0-3)
#'
#' `FontStyle` determines the font style.
#'
#' @details
#' The following styles are available:
#'
#' * `Normal`: Normal (plain).
#' * `Bold`: Bold (bold).
#' * `Italic`: Italic (italic).
#' * `BoldItalic`: BoldItalic (bold.italic).
#'
#' @seealso
#' [FontStyle in skia_safe - Rust](https://rust-skia.github.io/doc/skia_safe/struct.FontStyle.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-fontstyle
#' @export
`FontStyle` <- new.env(parent = emptyenv())
`FontStyle`$`Normal` <- .savvy_wrap_FontStyle(0L)
`FontStyle`$`Bold` <- .savvy_wrap_FontStyle(1L)
`FontStyle`$`Italic` <- .savvy_wrap_FontStyle(2L)
`FontStyle`$`BoldItalic` <- .savvy_wrap_FontStyle(3L)

#' @export
`$.FontStyle__bundle` <- function(x, name) {
  if (!name %in% c("Normal", "Bold", "Italic", "BoldItalic")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.FontStyle__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("FontStyle cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Normal", "Bold", "Italic", "BoldItalic")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.FontStyle` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Normal", "Bold", "Italic", "BoldItalic")[idx]
  if (is.na(label)) {
    stop("Unexpected value for FontStyle", call. = TRUE)
  }
  cat("FontStyle::", label, "\n", sep = "")
}


### associated functions for FontStyle



class(`FontStyle`) <- c("FontStyle__bundle", "savvy_skiagd__sealed")

#' @export
`print.FontStyle__bundle` <- function(x, ...) {
  cat('FontStyle\n')
}

### wrapper functions for ImageFilter

`ImageFilter_get_label` <- function(self) {
  function() {
    .Call(savvy_ImageFilter_get_label__impl, `self`)
  }
}

`.savvy_wrap_ImageFilter` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  e$`get_label` <- `ImageFilter_get_label`(ptr)

  class(e) <- c("ImageFilter", "savvy_skiagd__sealed")
  e
}


#' @export
`ImageFilter` <- new.env(parent = emptyenv())

### associated functions for ImageFilter

`ImageFilter`$`no_filter` <- function() {
  .savvy_wrap_ImageFilter(.Call(savvy_ImageFilter_no_filter__impl))
}

`ImageFilter`$`runtime_shader` <- function(`source`, `uniforms`) {
  `source` <- .savvy_extract_ptr(`source`, "RuntimeEffect")
  .savvy_wrap_ImageFilter(.Call(savvy_ImageFilter_runtime_shader__impl, `source`, `uniforms`))
}


class(`ImageFilter`) <- c("ImageFilter__bundle", "savvy_skiagd__sealed")

#' @export
`print.ImageFilter__bundle` <- function(x, ...) {
  cat('ImageFilter\n')
}

### wrapper functions for Join


`.savvy_wrap_Join` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("Join", "savvy_skiagd__sealed")
  e
}


#' Join (0-2)
#'
#' `Join` determines the stroke join (the geometry drawn at the corners of strokes) for shapes.
#'
#' @details
#' The following joins are available:
#'
#' * `Miter`: Miter join.
#' * `Round`: Round join.
#' * `Bevel`: Bevel join.
#'
#' @seealso
#' [Join in skia_safe::paint - Rust](https://rust-skia.github.io/doc/skia_safe/paint/enum.Join.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-join
#' @export
`Join` <- new.env(parent = emptyenv())
`Join`$`Miter` <- .savvy_wrap_Join(0L)
`Join`$`Round` <- .savvy_wrap_Join(1L)
`Join`$`Bevel` <- .savvy_wrap_Join(2L)

#' @export
`$.Join__bundle` <- function(x, name) {
  if (!name %in% c("Miter", "Round", "Bevel")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.Join__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("Join cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Miter", "Round", "Bevel")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.Join` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Miter", "Round", "Bevel")[idx]
  if (is.na(label)) {
    stop("Unexpected value for Join", call. = TRUE)
  }
  cat("Join::", label, "\n", sep = "")
}


### associated functions for Join



class(`Join`) <- c("Join__bundle", "savvy_skiagd__sealed")

#' @export
`print.Join__bundle` <- function(x, ...) {
  cat('Join\n')
}

### wrapper functions for PaintAttrs


`.savvy_wrap_PaintAttrs` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("PaintAttrs", "savvy_skiagd__sealed")
  e
}


#' PaintAttrs
#'
#' Internal impl that wraps `skia_safe::Paint`.
#' Use `PaintAttrs$set_attrs()` to create a new PaintAttrs
#' each time it is required, since `props` is always moved.
#'
#' @details
#' `PaintAttrs$set_attrs()` takes arguments below:
#'
#' * color: RGBA representaion of a color.
#' * style: Style (stroke style).
#' * join: Join (stroke join).
#' * cap: Cap (stroke cap).
#' * width: Stroke width.
#' * miter: Stroke miter.
#' * fontsize: Font size.
#' * family: Font family name
#' * fontface: FontStyle.
#' * blend_mode: BlendMode.
#' * path_effect: PathEffect.
#' * shader: Shader.
#' * image_filter: ImageFilter.
#'
#' @noRd
`PaintAttrs` <- new.env(parent = emptyenv())

### associated functions for PaintAttrs

`PaintAttrs`$`set_attrs` <- function(`color`, `style`, `join`, `cap`, `width`, `miter`, `fontsize`, `family`, `fontface`, `blend_mode`, `path_effect`, `shader`, `image_filter`) {
  `style` <- .savvy_extract_ptr(`style`, "Style")
  `join` <- .savvy_extract_ptr(`join`, "Join")
  `cap` <- .savvy_extract_ptr(`cap`, "Cap")
  `fontface` <- .savvy_extract_ptr(`fontface`, "FontStyle")
  `blend_mode` <- .savvy_extract_ptr(`blend_mode`, "BlendMode")
  `path_effect` <- .savvy_extract_ptr(`path_effect`, "PathEffect")
  `shader` <- .savvy_extract_ptr(`shader`, "Shader")
  `image_filter` <- .savvy_extract_ptr(`image_filter`, "ImageFilter")
  .savvy_wrap_PaintAttrs(.Call(savvy_PaintAttrs_set_attrs__impl, `color`, `style`, `join`, `cap`, `width`, `miter`, `fontsize`, `family`, `fontface`, `blend_mode`, `path_effect`, `shader`, `image_filter`))
}


class(`PaintAttrs`) <- c("PaintAttrs__bundle", "savvy_skiagd__sealed")

#' @export
`print.PaintAttrs__bundle` <- function(x, ...) {
  cat('PaintAttrs\n')
}

### wrapper functions for PathEffect

`PathEffect_get_label` <- function(self) {
  function() {
    .Call(savvy_PathEffect_get_label__impl, `self`)
  }
}

`.savvy_wrap_PathEffect` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  e$`get_label` <- `PathEffect_get_label`(ptr)

  class(e) <- c("PathEffect", "savvy_skiagd__sealed")
  e
}


#' @export
`PathEffect` <- new.env(parent = emptyenv())

### associated functions for PathEffect

`PathEffect`$`corner` <- function(`radius`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_corner__impl, `radius`))
}

`PathEffect`$`dash` <- function(`intervals`, `phase`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_dash__impl, `intervals`, `phase`))
}

`PathEffect`$`discrete` <- function(`length`, `deviation`, `seed`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_discrete__impl, `length`, `deviation`, `seed`))
}

`PathEffect`$`line_2d` <- function(`width`, `transform`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_line_2d__impl, `width`, `transform`))
}

`PathEffect`$`no_effect` <- function() {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_no_effect__impl))
}

`PathEffect`$`path_1d` <- function(`path`, `advance`, `phase`, `style`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_path_1d__impl, `path`, `advance`, `phase`, `style`))
}

`PathEffect`$`path_2d` <- function(`path`, `transform`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_path_2d__impl, `path`, `transform`))
}

`PathEffect`$`sum` <- function(`first`, `second`) {
  `first` <- .savvy_extract_ptr(`first`, "PathEffect")
  `second` <- .savvy_extract_ptr(`second`, "PathEffect")
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_sum__impl, `first`, `second`))
}

`PathEffect`$`trim` <- function(`start`, `end`) {
  .savvy_wrap_PathEffect(.Call(savvy_PathEffect_trim__impl, `start`, `end`))
}


class(`PathEffect`) <- c("PathEffect__bundle", "savvy_skiagd__sealed")

#' @export
`print.PathEffect__bundle` <- function(x, ...) {
  cat('PathEffect\n')
}

### wrapper functions for PointMode


`.savvy_wrap_PointMode` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("PointMode", "savvy_skiagd__sealed")
  e
}


#' PointMode (0-2)
#'
#' `PointMode` determines how points are drawn.
#' This is for [add_point()] only. Not used in other functions.
#'
#' @details
#' The following `PointMode` are available:
#'
#' * `Points`: Draws each `point` as a point. The shape of point drawn depends on `props`.
#' * `Lines`: Each pair of `point` draws a line segment. One line is drawn for every two points; each point is used once. If count is odd, the final point is ignored.
#' * `Polygon`: Each adjacent pair of `point` draws a line segment. count minus one lines are drawn; the first and last point are used once.
#'
#' @seealso
#' [PointMode in skia_safe::canvas - Rust](https://rust-skia.github.io/doc/skia_safe/canvas/enum.PointMode.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-pointmode
#' @export
`PointMode` <- new.env(parent = emptyenv())
`PointMode`$`Points` <- .savvy_wrap_PointMode(0L)
`PointMode`$`Lines` <- .savvy_wrap_PointMode(1L)
`PointMode`$`Polygon` <- .savvy_wrap_PointMode(2L)

#' @export
`$.PointMode__bundle` <- function(x, name) {
  if (!name %in% c("Points", "Lines", "Polygon")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.PointMode__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("PointMode cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Points", "Lines", "Polygon")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.PointMode` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Points", "Lines", "Polygon")[idx]
  if (is.na(label)) {
    stop("Unexpected value for PointMode", call. = TRUE)
  }
  cat("PointMode::", label, "\n", sep = "")
}


### associated functions for PointMode



class(`PointMode`) <- c("PointMode__bundle", "savvy_skiagd__sealed")

#' @export
`print.PointMode__bundle` <- function(x, ...) {
  cat('PointMode\n')
}

### wrapper functions for RuntimeEffect

`RuntimeEffect_source` <- function(self) {
  function() {
    .Call(savvy_RuntimeEffect_source__impl, `self`)
  }
}

`.savvy_wrap_RuntimeEffect` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  e$`source` <- `RuntimeEffect_source`(ptr)

  class(e) <- c("RuntimeEffect", "savvy_skiagd__sealed")
  e
}


#' @export
`RuntimeEffect` <- new.env(parent = emptyenv())

### associated functions for RuntimeEffect

`RuntimeEffect`$`make` <- function(`sksl`) {
  .savvy_wrap_RuntimeEffect(.Call(savvy_RuntimeEffect_make__impl, `sksl`))
}


class(`RuntimeEffect`) <- c("RuntimeEffect__bundle", "savvy_skiagd__sealed")

#' @export
`print.RuntimeEffect__bundle` <- function(x, ...) {
  cat('RuntimeEffect\n')
}

### wrapper functions for Shader

`Shader_get_label` <- function(self) {
  function() {
    .Call(savvy_Shader_get_label__impl, `self`)
  }
}

`.savvy_wrap_Shader` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  e$`get_label` <- `Shader_get_label`(ptr)

  class(e) <- c("Shader", "savvy_skiagd__sealed")
  e
}


#' @export
`Shader` <- new.env(parent = emptyenv())

### associated functions for Shader

`Shader`$`blend` <- function(`mode`, `dst`, `src`) {
  `mode` <- .savvy_extract_ptr(`mode`, "BlendMode")
  `dst` <- .savvy_extract_ptr(`dst`, "Shader")
  `src` <- .savvy_extract_ptr(`src`, "Shader")
  .savvy_wrap_Shader(.Call(savvy_Shader_blend__impl, `mode`, `dst`, `src`))
}

`Shader`$`color` <- function(`rgba`) {
  .savvy_wrap_Shader(.Call(savvy_Shader_color__impl, `rgba`))
}

`Shader`$`conical_gradient` <- function(`start`, `end`, `radii`, `from`, `to`, `mode`, `flags`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_conical_gradient__impl, `start`, `end`, `radii`, `from`, `to`, `mode`, `flags`, `transform`))
}

`Shader`$`fractal_noise` <- function(`freq`, `octaves`, `seed`, `tile_size`) {
  .savvy_wrap_Shader(.Call(savvy_Shader_fractal_noise__impl, `freq`, `octaves`, `seed`, `tile_size`))
}

`Shader`$`from_picture` <- function(`img`, `mode`, `tile_size`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_from_picture__impl, `img`, `mode`, `tile_size`, `transform`))
}

`Shader`$`from_png` <- function(`png_bytes`, `mode`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_from_png__impl, `png_bytes`, `mode`, `transform`))
}

`Shader`$`from_runtime_effect` <- function(`source`, `uniforms`) {
  `source` <- .savvy_extract_ptr(`source`, "RuntimeEffect")
  .savvy_wrap_Shader(.Call(savvy_Shader_from_runtime_effect__impl, `source`, `uniforms`))
}

`Shader`$`linear_gradient` <- function(`start`, `end`, `from`, `to`, `mode`, `flags`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_linear_gradient__impl, `start`, `end`, `from`, `to`, `mode`, `flags`, `transform`))
}

`Shader`$`no_shader` <- function() {
  .savvy_wrap_Shader(.Call(savvy_Shader_no_shader__impl))
}

`Shader`$`radial_gradient` <- function(`center`, `radius`, `from`, `to`, `mode`, `flags`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_radial_gradient__impl, `center`, `radius`, `from`, `to`, `mode`, `flags`, `transform`))
}

`Shader`$`sweep_gradient` <- function(`center`, `start_angle`, `end_angle`, `from`, `to`, `mode`, `flags`, `transform`) {
  `mode` <- .savvy_extract_ptr(`mode`, "TileMode")
  .savvy_wrap_Shader(.Call(savvy_Shader_sweep_gradient__impl, `center`, `start_angle`, `end_angle`, `from`, `to`, `mode`, `flags`, `transform`))
}

`Shader`$`turbulence` <- function(`freq`, `octaves`, `seed`, `tile_size`) {
  .savvy_wrap_Shader(.Call(savvy_Shader_turbulence__impl, `freq`, `octaves`, `seed`, `tile_size`))
}


class(`Shader`) <- c("Shader__bundle", "savvy_skiagd__sealed")

#' @export
`print.Shader__bundle` <- function(x, ...) {
  cat('Shader\n')
}

### wrapper functions for Style


`.savvy_wrap_Style` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("Style", "savvy_skiagd__sealed")
  e
}


#' Style (0-2)
#'
#' `Style` determines the stroke style of shapes.
#'
#' @details
#' The following styles are available:
#'
#' * `StrokeAndFill`: Stroke and fill.
#' * `Stroke`: Stroke only.
#' * `Fill`: Fill only.
#'
#' @seealso
#' [Style in skia_safe::paint - Rust](https://rust-skia.github.io/doc/skia_safe/paint/enum.Style.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-style
#' @export
`Style` <- new.env(parent = emptyenv())
`Style`$`StrokeAndFill` <- .savvy_wrap_Style(0L)
`Style`$`Stroke` <- .savvy_wrap_Style(1L)
`Style`$`Fill` <- .savvy_wrap_Style(2L)

#' @export
`$.Style__bundle` <- function(x, name) {
  if (!name %in% c("StrokeAndFill", "Stroke", "Fill")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.Style__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("Style cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("StrokeAndFill", "Stroke", "Fill")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.Style` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("StrokeAndFill", "Stroke", "Fill")[idx]
  if (is.na(label)) {
    stop("Unexpected value for Style", call. = TRUE)
  }
  cat("Style::", label, "\n", sep = "")
}


### associated functions for Style



class(`Style`) <- c("Style__bundle", "savvy_skiagd__sealed")

#' @export
`print.Style__bundle` <- function(x, ...) {
  cat('Style\n')
}

### wrapper functions for TileMode


`.savvy_wrap_TileMode` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("TileMode", "savvy_skiagd__sealed")
  e
}


#' TileMode (0-3)
#'
#' `TileMode` determines how the source is tiled for shaders.
#' This is not a paint attribute. To specify `TileMode`, directly pass these pointers to shader functions.
#'
#' @details
#' The following `TileMode` are available:
#'
#' * `Clamp`
#' * `Repeat`
#' * `Mirror`
#' * `Decal`
#'
#' @seealso
#' [TileMode in skia_safe - Rust](https://rust-skia.github.io/doc/skia_safe/enum.TileMode.html)
#' @rdname skiagd-attrs-tilemode
#' @export
`TileMode` <- new.env(parent = emptyenv())
`TileMode`$`Clamp` <- .savvy_wrap_TileMode(0L)
`TileMode`$`Repeat` <- .savvy_wrap_TileMode(1L)
`TileMode`$`Mirror` <- .savvy_wrap_TileMode(2L)
`TileMode`$`Decal` <- .savvy_wrap_TileMode(3L)

#' @export
`$.TileMode__bundle` <- function(x, name) {
  if (!name %in% c("Clamp", "Repeat", "Mirror", "Decal")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.TileMode__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("TileMode cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Clamp", "Repeat", "Mirror", "Decal")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.TileMode` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Clamp", "Repeat", "Mirror", "Decal")[idx]
  if (is.na(label)) {
    stop("Unexpected value for TileMode", call. = TRUE)
  }
  cat("TileMode::", label, "\n", sep = "")
}


### associated functions for TileMode



class(`TileMode`) <- c("TileMode__bundle", "savvy_skiagd__sealed")

#' @export
`print.TileMode__bundle` <- function(x, ...) {
  cat('TileMode\n')
}

### wrapper functions for VertexMode


`.savvy_wrap_VertexMode` <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr


  class(e) <- c("VertexMode", "savvy_skiagd__sealed")
  e
}


#' VertexMode (0-2)
#'
#' `VertexMode` determines how vertices are drawn.
#' This is for [add_vertices()] only. Not used in other functions.
#'
#' @details
#' The following `VertexMode` are available:
#'
#' * `Triangles`
#' * `TriangleStrip`
#' * `TriangleFan`
#'
#' @seealso
#' [VertexMode in skia_safe::vertices - Rust](https://rust-skia.github.io/doc/skia_safe/vertices/enum.VertexMode.html)
#' @family paint-attributes
#' @rdname skiagd-attrs-vertexmode
#' @export
`VertexMode` <- new.env(parent = emptyenv())
`VertexMode`$`Triangles` <- .savvy_wrap_VertexMode(0L)
`VertexMode`$`TriangleStrip` <- .savvy_wrap_VertexMode(1L)
`VertexMode`$`TriangleFan` <- .savvy_wrap_VertexMode(2L)

#' @export
`$.VertexMode__bundle` <- function(x, name) {
  if (!name %in% c("Triangles", "TriangleStrip", "TriangleFan")) {
    stop(paste0("Unknown variant: ", name), call. = FALSE)
  }

  NextMethod()
}

#' @export
`[[.VertexMode__bundle` <- function(x, i) {
  if (is.numeric(i)) {
    stop("VertexMode cannot be subset by index", call. = FALSE)
  }

  if (!i %in% c("Triangles", "TriangleStrip", "TriangleFan")) {
    stop(paste0("Unknown variant: ", i), call. = FALSE)
  }

  NextMethod()
}

#' @export
`print.VertexMode` <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Triangles", "TriangleStrip", "TriangleFan")[idx]
  if (is.na(label)) {
    stop("Unexpected value for VertexMode", call. = TRUE)
  }
  cat("VertexMode::", label, "\n", sep = "")
}


### associated functions for VertexMode



class(`VertexMode`) <- c("VertexMode__bundle", "savvy_skiagd__sealed")

#' @export
`print.VertexMode__bundle` <- function(x, ...) {
  cat('VertexMode\n')
}

